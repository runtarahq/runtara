syntax = "proto3";
package runtara.instance;

// ============================================================================
// Instance Protocol - Used by instances to communicate with runtara-core
// ============================================================================

// ============================================================================
// Instance Registration (instance → core)
// ============================================================================

// Instance self-registers when it starts
message RegisterInstanceRequest {
  string instance_id = 1;
  string tenant_id = 2;
  optional string checkpoint_id = 3;  // Resuming from checkpoint (optional)
}

message RegisterInstanceResponse {
  bool success = 1;
  string error = 2;
}

// ============================================================================
// Checkpointing (instance → core) - Append-only log
// ============================================================================

// Checkpoint operation - handles both save and resume:
// - If checkpoint with this ID exists, returns existing state (for resume)
// - If checkpoint doesn't exist, saves state and returns empty (fresh execution)
//
// Also serves as heartbeat - reports progress to core.
message CheckpointRequest {
  string instance_id = 1;
  string checkpoint_id = 2;     // Opaque identifier for resume point
  bytes state = 3;              // State to save (ignored if checkpoint exists)
}

message CheckpointResponse {
  bool found = 1;               // true = existing checkpoint returned, false = new checkpoint saved
  bytes state = 2;              // Existing state if found, empty if saved
  optional Signal pending_signal = 3;      // Instance-wide signal (cancel/pause/resume) if pending
  optional CustomSignal custom_signal = 4; // Checkpoint-scoped custom signal (if matching checkpoint_id)
  optional StructuredError last_error = 5; // Last error if resuming after failure
}

// Get checkpoint without saving - read-only lookup
message GetCheckpointRequest {
  string instance_id = 1;
  string checkpoint_id = 2;     // Checkpoint ID to look up
}

message GetCheckpointResponse {
  bool found = 1;               // true = checkpoint exists
  bytes state = 2;              // Checkpoint state if found
}

// ============================================================================
// Sleep/Wake (durable execution)
// ============================================================================

// Instance requests to sleep. Sleep is always handled in-process.
message SleepRequest {
  string instance_id = 1;
  uint64 duration_ms = 2;
  string checkpoint_id = 3;     // Where to resume after wake
  bytes state = 4;              // State to restore on wake
}

// Empty response - sleep always completes in-process.
// Managed environments may hibernate containers separately based on idleness.
message SleepResponse {}

// ============================================================================
// Instance Events (instance → core)
// ============================================================================

message InstanceEvent {
  string instance_id = 1;
  InstanceEventType event_type = 2;
  optional string checkpoint_id = 3;  // Current position (for PROGRESS)
  bytes payload = 4;                  // Event-specific data (output, error, etc.)
  int64 timestamp_ms = 5;
  optional string subtype = 6;        // Arbitrary subtype for EVENT_CUSTOM
}

enum InstanceEventType {
  EVENT_HEARTBEAT = 0;    // Simple "I'm alive" signal (no checkpoint)
  EVENT_COMPLETED = 2;    // Instance finished successfully, payload = output
  EVENT_FAILED = 3;       // Instance failed, payload = error details
  EVENT_SUSPENDED = 4;    // Instance suspended (waiting for wake)
  EVENT_CUSTOM = 5;       // Generic custom event with arbitrary subtype
  // Deprecated: EVENT_STARTED (use heartbeat), EVENT_PROGRESS (use checkpoint or heartbeat)
}

// Response for all instance events.
// Acknowledges that the event was persisted to the database.
// All events use request-response to ensure no events are lost.
message InstanceEventResponse {
  bool success = 1;
  optional string error = 2;
}

// Batch of events (for efficiency)
message InstanceEventBatch {
  repeated InstanceEvent events = 1;
}

// ============================================================================
// Retry Tracking (instance → core, fire-and-forget)
// ============================================================================

// Records a retry attempt for audit trail.
// Sent when a durable function fails and is about to be retried.
message RetryAttemptEvent {
  string instance_id = 1;
  string checkpoint_id = 2;       // The durable function's cache key
  uint32 attempt_number = 3;      // 1-indexed retry attempt number
  int64 timestamp_ms = 4;         // When the attempt started
  optional string error_message = 5;       // Error from previous attempt (if retrying)
  optional ErrorMetadata error_metadata = 6; // Structured error info for retry decisions
}

// ============================================================================
// Signals (instance polls for signals from core)
// ============================================================================

enum SignalType {
  SIGNAL_CANCEL = 0;      // Cancel execution
  SIGNAL_PAUSE = 1;       // Pause execution (checkpoint and wait)
  SIGNAL_RESUME = 2;      // Resume paused execution
}

// Signal forwarded from core to instance
message Signal {
  string instance_id = 1;
  SignalType signal_type = 2;
  bytes payload = 3;
}

// Custom signal targeted at a specific checkpoint_id (wait key)
message CustomSignal {
  string checkpoint_id = 1;
  bytes payload = 2;
}

// Instance acknowledges received signal
message SignalAck {
  string instance_id = 1;
  SignalType signal_type = 2;
  bool acknowledged = 3;
}

// Instance polls for pending signals
message PollSignalsRequest {
  string instance_id = 1;
  // Optional checkpoint_id to fetch a custom signal scoped to a specific wait/checkpoint
  optional string checkpoint_id = 2;
}

message PollSignalsResponse {
  optional Signal signal = 1;         // Pending instance-wide signal if any, or empty
  optional CustomSignal custom_signal = 2; // Pending checkpoint-scoped custom signal (if checkpoint_id was provided)
}

// ============================================================================
// Instance Status Query (instance can query its own status)
// ============================================================================

message GetInstanceStatusRequest {
  string instance_id = 1;
}

message GetInstanceStatusResponse {
  string instance_id = 1;
  InstanceStatus status = 2;
  optional string checkpoint_id = 3;  // Last known checkpoint
  int64 started_at_ms = 4;
  optional int64 finished_at_ms = 5;
  optional bytes output = 6;          // If completed
  optional string error = 7;          // If failed
}

enum InstanceStatus {
  STATUS_UNKNOWN = 0;
  STATUS_PENDING = 1;     // Queued, not yet started
  STATUS_RUNNING = 2;     // Currently executing
  STATUS_SUSPENDED = 3;   // Sleeping / waiting for wake
  STATUS_COMPLETED = 4;   // Finished successfully
  STATUS_FAILED = 5;      // Finished with error
  STATUS_CANCELLED = 6;   // Cancelled by signal
}

// ============================================================================
// RPC Wrapper (for multiplexing on single stream)
// ============================================================================

// Wrapper for all instance request types
message RpcRequest {
  oneof request {
    RegisterInstanceRequest register_instance = 1;
    SleepRequest sleep = 4;
    InstanceEvent instance_event = 5;
    InstanceEventBatch instance_event_batch = 6;
    GetInstanceStatusRequest get_instance_status = 7;
    CheckpointRequest checkpoint = 8;
    GetCheckpointRequest get_checkpoint = 9;
    PollSignalsRequest poll_signals = 10;
    SignalAck signal_ack = 11;
    RetryAttemptEvent retry_attempt = 12;
    // Compensation (saga pattern)
    RegisterCompensatableRequest register_compensatable = 13;
    TriggerCompensationRequest trigger_compensation = 14;
    GetCompensationStatusRequest get_compensation_status = 16;
    CompleteCompensationRequest complete_compensation = 17;
  }
}

// Wrapper for all instance response types
message RpcResponse {
  oneof response {
    RegisterInstanceResponse register_instance = 1;
    SleepResponse sleep = 4;
    InstanceEventResponse instance_event = 5;  // Response for all instance events (acknowledges persistence)
    // SignalAck and RetryAttempt remain fire-and-forget (audit-only, no delivery guarantee needed)
    GetInstanceStatusResponse get_instance_status = 7;
    CheckpointResponse checkpoint = 8;
    GetCheckpointResponse get_checkpoint = 9;
    PollSignalsResponse poll_signals = 10;
    RpcError error = 15;
    // Compensation (saga pattern)
    RegisterCompensatableResponse register_compensatable = 13;
    TriggerCompensationResponse trigger_compensation = 14;
    GetCompensationStatusResponse get_compensation_status = 16;
    CompleteCompensationResponse complete_compensation = 17;
  }
}

// Generic RPC error
message RpcError {
  string code = 1;
  string message = 2;
}

// ============================================================================
// Structured Error Types
// ============================================================================

// Error category determines retry behavior
enum ErrorCategory {
  ERROR_CATEGORY_UNKNOWN = 0;    // Unknown - use default retry policy
  ERROR_CATEGORY_TRANSIENT = 1;  // Transient - retry recommended (network, timeout, rate limit)
  ERROR_CATEGORY_PERMANENT = 2;  // Permanent - don't retry (validation, not found, auth)
  ERROR_CATEGORY_BUSINESS = 3;   // Business rule violation - may need escalation
}

// Error severity for alerting/logging
enum ErrorSeverity {
  ERROR_SEVERITY_INFO = 0;      // Informational (expected errors)
  ERROR_SEVERITY_WARNING = 1;   // Warning (degraded but functional)
  ERROR_SEVERITY_ERROR = 2;     // Error (operation failed)
  ERROR_SEVERITY_CRITICAL = 3;  // Critical (system-level failure)
}

// Retry hint from error source
enum RetryHint {
  RETRY_HINT_UNKNOWN = 0;            // No hint - use default policy
  RETRY_HINT_RETRY_IMMEDIATELY = 1;  // Retry now (transient glitch)
  RETRY_HINT_RETRY_WITH_BACKOFF = 2; // Retry with exponential backoff
  RETRY_HINT_RETRY_AFTER = 3;        // Retry after specific duration (rate limit)
  RETRY_HINT_DO_NOT_RETRY = 4;       // Don't retry (permanent error)
}

// Extended error metadata
message ErrorMetadata {
  ErrorCategory category = 1;
  ErrorSeverity severity = 2;
  RetryHint retry_hint = 3;
  optional uint64 retry_after_ms = 4;  // For RETRY_AFTER hint
  optional string error_code = 5;      // Machine-readable code (e.g., "RATE_LIMITED")
  map<string, string> attributes = 6;  // Additional context (step_id, agent_id, etc.)
}

// Enhanced error with structured metadata
message StructuredError {
  string code = 1;                     // Error code (e.g., "VALIDATION_ERROR")
  string message = 2;                  // Human-readable message
  optional ErrorMetadata metadata = 3; // Structured metadata
  optional string source_step_id = 4;  // Which step produced the error
  optional bytes cause = 5;            // Serialized cause error (for chaining)
}

// ============================================================================
// Compensation (Saga Pattern)
// ============================================================================

// Compensation state for a checkpoint
enum CompensationState {
  COMPENSATION_NONE = 0;        // No compensation defined
  COMPENSATION_PENDING = 1;     // Compensation may be needed
  COMPENSATION_TRIGGERED = 2;   // Compensation in progress
  COMPENSATION_COMPLETED = 3;   // Compensation finished successfully
  COMPENSATION_FAILED = 4;      // Compensation failed
}

// Checkpoint with compensation metadata
message CompensatableCheckpoint {
  string checkpoint_id = 1;
  bytes state = 2;
  string compensation_step_id = 3;  // Step to execute for rollback
  bytes compensation_data = 4;      // Data for compensation step
  CompensationState compensation_state = 5;
  int32 compensation_order = 6;     // Execution order during rollback
}

// Register a checkpoint as compensatable
message RegisterCompensatableRequest {
  string instance_id = 1;
  string checkpoint_id = 2;
  string step_id = 3;                 // Current step that may need compensation
  string compensation_step_id = 4;    // Step to execute for rollback
  bytes compensation_data = 5;        // Data needed for compensation
  int32 compensation_order = 6;       // Order in rollback sequence
}

message RegisterCompensatableResponse {
  bool success = 1;
  optional string error = 2;
}

// Request to trigger compensation for an instance
message TriggerCompensationRequest {
  string instance_id = 1;
  optional string from_checkpoint_id = 2;  // Start compensation from this checkpoint
  optional string reason = 3;              // Why compensation was triggered
}

message TriggerCompensationResponse {
  bool success = 1;
  optional string error = 2;
  int32 steps_to_compensate = 3;  // Number of steps that will be rolled back
}

// Get compensation status
message GetCompensationStatusRequest {
  string instance_id = 1;
}

message GetCompensationStatusResponse {
  CompensationState state = 1;
  int32 total_steps = 2;
  int32 completed_steps = 3;
  repeated CompensatableCheckpoint pending_compensations = 4;
  optional StructuredError last_error = 5;
}

// Mark a compensation step as completed
message CompleteCompensationRequest {
  string instance_id = 1;
  string checkpoint_id = 2;
  bool success = 3;
  optional StructuredError error = 4;
}

message CompleteCompensationResponse {
  bool all_completed = 1;        // True if all compensations are done
  bool all_succeeded = 2;        // True if all completed successfully
  optional string error = 3;
}
