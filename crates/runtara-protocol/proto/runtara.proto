syntax = "proto3";
package runtara;

// ============================================================================
// Instance Registration (instance → core)
// ============================================================================

// Instance self-registers when it starts
message RegisterInstanceRequest {
  string instance_id = 1;
  string tenant_id = 2;
  optional string checkpoint_id = 3;  // Resuming from checkpoint (optional)
}

message RegisterInstanceResponse {
  bool success = 1;
  string error = 2;
}

// ============================================================================
// Checkpointing (instance → core) - Append-only log
// ============================================================================

message SaveCheckpointRequest {
  string instance_id = 1;
  string checkpoint_id = 2;     // Opaque identifier for resume point
  bytes state = 3;              // Serialized state blob
}

message SaveCheckpointResponse {
  bool success = 1;
}

message LoadCheckpointRequest {
  string instance_id = 1;
  optional string checkpoint_id = 2;  // If not specified, load latest
}

message LoadCheckpointResponse {
  bool found = 1;
  string checkpoint_id = 2;
  bytes state = 3;
}

// ============================================================================
// Sleep/Wake (durable execution)
// ============================================================================

// Instance requests to sleep. Core decides if in-process or deferred.
message SleepRequest {
  string instance_id = 1;
  uint64 duration_ms = 2;
  string checkpoint_id = 3;     // Where to resume after wake
  bytes state = 4;              // State to restore on wake
}

message SleepResponse {
  bool deferred = 1;            // true = instance should exit, core will wake later
                                // false = slept in-process, continue execution
}

// ============================================================================
// Instance Events (instance → core, streaming)
// ============================================================================

message InstanceEvent {
  string instance_id = 1;
  InstanceEventType event_type = 2;
  optional string checkpoint_id = 3;  // Current position (for PROGRESS)
  bytes payload = 4;                  // Event-specific data (output, error, etc.)
  int64 timestamp_ms = 5;
}

enum InstanceEventType {
  EVENT_STARTED = 0;      // Instance began execution
  EVENT_PROGRESS = 1;     // Heartbeat / progress update with optional checkpoint
  EVENT_COMPLETED = 2;    // Instance finished successfully, payload = output
  EVENT_FAILED = 3;       // Instance failed, payload = error details
  EVENT_SUSPENDED = 4;    // Instance suspended (waiting for wake)
}

// Batch of events (for efficiency)
message InstanceEventBatch {
  repeated InstanceEvent events = 1;
}

// ============================================================================
// Signals (external → core → instance)
// ============================================================================

enum SignalType {
  SIGNAL_CANCEL = 0;      // Cancel execution
  SIGNAL_PAUSE = 1;       // Pause execution (checkpoint and wait)
  SIGNAL_RESUME = 2;      // Resume paused execution
}

// External client (via SDK) requests core to send a signal to an instance
message SendSignalRequest {
  string instance_id = 1;
  SignalType signal_type = 2;
  bytes payload = 3;            // Signal-specific data (e.g., cancel reason)
}

message SendSignalResponse {
  bool success = 1;
  string error = 2;             // Error if instance not found, not connected, etc.
}

// Signal forwarded from core to instance (server-initiated)
message Signal {
  string instance_id = 1;
  SignalType signal_type = 2;
  bytes payload = 3;
}

// Instance acknowledges received signal
message SignalAck {
  string instance_id = 1;
  SignalType signal_type = 2;
  bool acknowledged = 3;
}

// Instance polls for pending signals (alternative to server-push)
message PollSignalsRequest {
  string instance_id = 1;
}

message PollSignalsResponse {
  optional Signal signal = 1;   // Pending signal if any, or empty
}

// ============================================================================
// Instance Status Query
// ============================================================================

message GetInstanceStatusRequest {
  string instance_id = 1;
}

message GetInstanceStatusResponse {
  string instance_id = 1;
  InstanceStatus status = 2;
  optional string checkpoint_id = 3;  // Last known checkpoint
  int64 started_at_ms = 4;
  optional int64 finished_at_ms = 5;
  optional bytes output = 6;          // If completed
  optional string error = 7;          // If failed
}

enum InstanceStatus {
  STATUS_UNKNOWN = 0;
  STATUS_PENDING = 1;     // Queued, not yet started
  STATUS_RUNNING = 2;     // Currently executing
  STATUS_SUSPENDED = 3;   // Sleeping / waiting for wake
  STATUS_COMPLETED = 4;   // Finished successfully
  STATUS_FAILED = 5;      // Finished with error
  STATUS_CANCELLED = 6;   // Cancelled by signal
}

// ============================================================================
// Health Check
// ============================================================================

message HealthCheckRequest {}

message HealthCheckResponse {
  bool healthy = 1;
  string version = 2;
  int64 uptime_ms = 3;
  uint32 active_instances = 4;
}

// ============================================================================
// RPC Wrapper (for multiplexing on single stream)
// ============================================================================

// Wrapper for all request types
message RpcRequest {
  oneof request {
    RegisterInstanceRequest register_instance = 1;
    SaveCheckpointRequest save_checkpoint = 2;
    LoadCheckpointRequest load_checkpoint = 3;
    SleepRequest sleep = 4;
    InstanceEvent instance_event = 5;
    InstanceEventBatch instance_event_batch = 6;
    GetInstanceStatusRequest get_instance_status = 7;
    HealthCheckRequest health_check = 8;
    SendSignalRequest send_signal = 9;
    PollSignalsRequest poll_signals = 10;
    SignalAck signal_ack = 11;
  }
}

// Wrapper for all response types
message RpcResponse {
  oneof response {
    RegisterInstanceResponse register_instance = 1;
    SaveCheckpointResponse save_checkpoint = 2;
    LoadCheckpointResponse load_checkpoint = 3;
    SleepResponse sleep = 4;
    // InstanceEvent/Batch/SignalAck don't have responses (fire-and-forget)
    GetInstanceStatusResponse get_instance_status = 7;
    HealthCheckResponse health_check = 8;
    SendSignalResponse send_signal = 9;
    PollSignalsResponse poll_signals = 10;
    RpcError error = 15;
  }
}

// Generic RPC error
message RpcError {
  string code = 1;
  string message = 2;
}
